<!DOCTYPE html>
<html lang="en">
<head>
    <title>Blender Shortcuts</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="screen.css" media="screen">
</head>
<body>
    <div id="header">
        <h1>Blender Shortcuts</h1>
        <p>This website provides a selection of useful default shortcuts in <a href="https://www.blender.org/" target="_blank">Blender</a>. For the best user experience, a mouse with a <em class="important">wheel</em> and a keyboard with a <em class="important">numpad</em> are recommended.</p>
        <p>Suggest changes to this website via <a href="https://github.com/Slaytex/blendershorts/" target="_blank">Github</a>.</p>
    </div>

    <div class="main" id="mainContainer">
        <!-- Items will be generated here by JavaScript -->
    </div>

    <div id="menu">
        <button type="button" id="buttonMenu" class="hidden">&#9776;</button>
        <button type="button" id="buttonContent" class="hidden">Collapse</button>
        <div id="filter" class="hidden">
            <button type="button" class="buttonTag active" data-index="0">All</button>
            <button type="button" class="buttonTag" data-index="1">General</button>
            <button type="button" class="buttonTag" data-index="2">Navigation</button>
            <button type="button" class="buttonTag" data-index="3">Selection</button>
            <button type="button" class="buttonTag" data-index="4">Modeling</button>
            <button type="button" class="buttonTag" data-index="5">Beginner</button>
            <button type="button" class="buttonTag" data-index="6">Wizard</button>
        </div>
    </div>

    <div class="edit-controls">
        <button id="btnAddShortcut">+ Add Shortcut</button>
        <button id="btnEditMode">Edit Mode</button>
    </div>

    <!-- Edit Modal -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">Add Shortcut</h2>
            <form id="shortcutForm">
                <label>Title:</label>
                <input type="text" id="inputTitle" required>
                
                <label>Shortcut:</label>
                <input type="text" id="inputShortcut" required>
                
                <label>Content (one per line, use &lt;em class="shortcut"&gt; for keys):</label>
                <textarea id="inputContent" rows="5" required></textarea>
                
                <label>Video filename (optional, e.g., "Add.mp4"):</label>
                <input type="text" id="inputVideo" placeholder="Leave empty if no video">
                
                <label>Tags (comma-separated):</label>
                <input type="text" id="inputTags" placeholder="1,2,3 (1=General, 2=Navigation, 3=Selection, 4=Modeling, 5=Beginner, 6=Wizard)">
                
                <button type="submit">Save</button>
                <button type="button" onclick="closeEditModal()">Cancel</button>
            </form>
        </div>
    </div>

    <script>
        const tagColors = ["rgba(8,8,8,0.5)", "rgba(204,130,115,0.4)", "rgba(226,170,125,0.4)", "rgba(240,207,142,0.4)", "rgba(246,237,206,0.4)", "rgba(168,200,166,0.4)", "rgba(108,141,138,0.4)", "rgba(100,80,88,0.4)"];
        const tagNames = ["All", "General", "Navigation", "Selection", "Modeling", "Beginner", "Wizard"];
        
        let shortcutsData = { shortcuts: [] };
        let editMode = false;
        let editingIndex = -1;

        const header = document.getElementById("header");
        const filter = document.getElementById("filter");
        const buttonMenu = document.getElementById("buttonMenu");
        const buttonContent = document.getElementById("buttonContent");
        const tagButtons = document.getElementsByClassName("buttonTag");
        const mainContainer = document.getElementById("mainContainer");

        let isMenu = false;
        let isContent = false;
        let highlighted = 0;

        // Load data
        async function loadData() {
            try {
                const response = await fetch('/api/shortcuts');
                if (!response.ok) throw new Error('Failed to load');
                const data = await response.json();
                
                // Convert from old format if needed
                if (data.categories) {
                    shortcutsData = await convertOldFormat(data);
                } else {
                    shortcutsData = data;
                }
                
                renderItems();
                initializeUI();
            } catch (error) {
                console.error('Error loading data:', error);
                // Try loading from local file
                try {
                    const response = await fetch('shortcuts-new.json');
                    shortcutsData = await response.json();
                    renderItems();
                    initializeUI();
                } catch (e) {
                    console.error('Failed to load shortcuts:', e);
                }
            }
        }

        // Convert old format to new format
        async function convertOldFormat(data) {
            const newFormat = { shortcuts: [] };
            const tagMap = {
                'Selection & Navigation': [2, 3],
                'Object Operations': [1],
                'Parenting': [1],
                'Keyframing & Animation': [1],
                '3D Cursor & Pivot Point': [2],
                'UV Mapping': [4],
                'Instances': [1],
                'Proportional Editing': [4],
                'Modifiers & Collections': [1],
                'Common Issues & Fixes': [1],
                'Useful View Modes': [2],
                'Tips': [1]
            };

            data.categories.forEach(category => {
                category.shortcuts.forEach(shortcut => {
                    const content = [];
                    if (shortcut.info && shortcut.info.trim()) {
                        content.push(shortcut.info);
                    }
                    if (category.notes && category.notes.length > 0) {
                        category.notes.forEach(note => {
                            if (note.trim()) {
                                content.push(note.replace(/^\*\*|\*\*$/g, '').replace(/\*\*/g, ''));
                            }
                        });
                    }
                    if (content.length === 0) {
                        content.push(`Use <em class="shortcut">${shortcut.shortcut}</em> to ${shortcut.action.toLowerCase()}.`);
                    }

                    newFormat.shortcuts.push({
                        id: generateId(shortcut.action),
                        title: shortcut.action,
                        shortcut: shortcut.shortcut,
                        content: content,
                        tags: tagMap[category.name] || [1]
                    });
                });
            });

            return newFormat;
        }

        function generateId(title) {
            return title.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '').replace(/^([a-z])/, m => m.toUpperCase());
        }

        function renderItems() {
            mainContainer.innerHTML = '';
            
            shortcutsData.shortcuts.forEach((shortcut, index) => {
                const item = document.createElement('div');
                item.className = 'item';
                item.id = shortcut.id;
                
                const itemLink = document.createElement('a');
                itemLink.className = 'itemLink';
                itemLink.href = `#${shortcut.id}`;
                
                const title = document.createElement('h3');
                title.textContent = shortcut.title;
                
                const shortcutKey = document.createElement('h3');
                const em = document.createElement('em');
                em.className = 'shortcut';
                em.textContent = shortcut.shortcut;
                shortcutKey.appendChild(em);
                
                itemLink.appendChild(title);
                itemLink.appendChild(shortcutKey);
                
                // Add video if available
                if (shortcut.video) {
                    const video = document.createElement('video');
                    video.autoplay = true;
                    video.loop = true;
                    video.muted = true;
                    video.playsInline = true;
                    video.poster = 'img/loading.jpg';
                    video.style.width = '256px';
                    video.style.position = 'relative';
                    video.style.left = '50%';
                    video.style.transform = 'translateX(-50%)';
                    video.style.marginTop = '30px';
                    video.style.borderRadius = '4px';
                    
                    const source = document.createElement('source');
                    source.src = `videos/${shortcut.video}`;
                    source.type = 'video/mp4';
                    video.appendChild(source);
                    
                    // Add error handling
                    video.addEventListener('error', (e) => {
                        console.error('Video error:', shortcut.video, e);
                    });
                    
                    // Try to play the video
                    video.addEventListener('loadeddata', () => {
                        video.play().catch(err => {
                            console.log('Autoplay prevented, user interaction required:', err);
                        });
                    });
                    
                    itemLink.appendChild(video);
                }
                
                const content = document.createElement('div');
                content.className = 'content hidden';
                const ul = document.createElement('ul');
                shortcut.content.forEach(line => {
                    const li = document.createElement('li');
                    const p = document.createElement('p');
                    p.innerHTML = line;
                    li.appendChild(p);
                    ul.appendChild(li);
                });
                content.appendChild(ul);
                
                const tags = document.createElement('div');
                tags.className = 'tags';
                shortcut.tags.forEach(tagIndex => {
                    const tag = document.createElement('div');
                    tag.className = 'tag';
                    tag.setAttribute('data-index', tagIndex);
                    tag.textContent = tagNames[tagIndex];
                    tags.appendChild(tag);
                });
                
                const collapse = document.createElement('a');
                collapse.className = 'itemCollapse';
                
                // Edit buttons (shown in edit mode)
                const editButtons = document.createElement('div');
                editButtons.className = 'edit-buttons';
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.onclick = () => openEditModal(index);
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = () => deleteShortcut(index);
                editButtons.appendChild(editBtn);
                editButtons.appendChild(deleteBtn);
                
                item.appendChild(itemLink);
                item.appendChild(content);
                item.appendChild(tags);
                item.appendChild(collapse);
                if (editMode) {
                    item.classList.add('edit-item');
                    item.appendChild(editButtons);
                }
                
                itemLink.addEventListener('click', (e) => {
                    // Don't prevent default on video clicks - let video controls work
                    if (e.target.tagName === 'VIDEO' || e.target.closest('video')) {
                        return;
                    }
                    e.preventDefault();
                    expandContent(index);
                    highlight(index);
                });
                
                collapse.addEventListener('click', () => {
                    toggleContent(index);
                });
                
                mainContainer.appendChild(item);
            });
        }

        function initializeUI() {
            buttonMenu.addEventListener('click', toggleMenu);
            buttonContent.addEventListener('click', toggleAllContent);

            for (let i = 0; i < tagButtons.length; i++) {
                const index = tagButtons[i].dataset.index;
                tagButtons[i].addEventListener('click', () => filterByTag(index));
                tagButtons[i].style.backgroundColor = tagColors[i];
            }

            buttonMenu.classList.toggle('hidden');
            readURLAnchor();
        }

        function toggleMenu() {
            isMenu = !isMenu;
            buttonContent.classList.toggle('hidden');
            if (!isMenu) {
                filter.classList.add('hidden');
            } else {
                filter.classList.remove('hidden');
            }
        }

        function expandContent(index) {
            const items = document.getElementsByClassName('item');
            const contents = items[index].getElementsByClassName('content');
            if (contents.length > 0) {
                contents[0].classList.remove('hidden');
            }
        }

        function toggleContent(index) {
            const items = document.getElementsByClassName('item');
            const contents = items[index].getElementsByClassName('content');
            if (contents.length > 0) {
                contents[0].classList.toggle('hidden');
            }
        }

        function toggleAllContent() {
            isContent = !isContent;
            const contents = document.getElementsByClassName('content');
            for (let i = 0; i < contents.length; i++) {
                if (isContent) {
                    contents[i].classList.add('hidden');
                } else {
                    contents[i].classList.remove('hidden');
                }
            }
            header.classList.toggle('hidden');
            buttonContent.innerHTML = isContent ? 'Expand' : 'Collapse';
        }

        function filterByTag(index) {
            for (let i = 0; i < tagButtons.length; i++) {
                tagButtons[i].classList.remove('active');
            }

            const tagCurrent = parseInt(index);
            if (!tagButtons[tagCurrent]) {
                console.log('Error! Tag ID does not exist!');
                return;
            }
            tagButtons[tagCurrent].classList.add('active');

            const items = document.getElementsByClassName('item');
            if (index != '0') {
                for (let i = 0; i < items.length; i++) {
                    const tags = items[i].getElementsByClassName('tag');
                    let hasTag = false;
                    for (let j = 0; j < tags.length; j++) {
                        if (tags[j].dataset.index == index) {
                            hasTag = true;
                            break;
                        }
                    }
                    if (hasTag) {
                        items[i].classList.remove('hidden');
                    } else {
                        items[i].classList.add('hidden');
                    }
                }
            } else {
                for (let i = 0; i < items.length; i++) {
                    items[i].classList.remove('hidden');
                }
            }
        }

        function readURLAnchor() {
            if (document.URL.split('#').length > 1) {
                let anchor = document.URL.split('#')[1];
                const items = document.getElementsByClassName('item');
                for (let i = 0; i < items.length; i++) {
                    if (items[i].id == anchor) {
                        highlight(i);
                        expandContent(i);
                        return;
                    }
                }
            }
        }

        function highlight(index) {
            const items = document.getElementsByClassName('item');
            const links = items[highlighted].getElementsByClassName('itemLink');
            if (links.length > 0) {
                links[0].classList.remove('highlight');
            }
            const newLinks = items[index].getElementsByClassName('itemLink');
            if (newLinks.length > 0) {
                newLinks[0].classList.add('highlight');
            }
            highlighted = index;
        }

        // Edit mode functions
        document.getElementById('btnEditMode').addEventListener('click', () => {
            editMode = !editMode;
            document.getElementById('btnEditMode').textContent = editMode ? 'View Mode' : 'Edit Mode';
            renderItems();
        });

        document.getElementById('btnAddShortcut').addEventListener('click', () => {
            editingIndex = -1;
            document.getElementById('modalTitle').textContent = 'Add Shortcut';
            document.getElementById('shortcutForm').reset();
            document.getElementById('editModal').style.display = 'block';
        });

        document.getElementById('shortcutForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const title = document.getElementById('inputTitle').value;
            const shortcut = document.getElementById('inputShortcut').value;
            const content = document.getElementById('inputContent').value.split('\n').filter(l => l.trim());
            const video = document.getElementById('inputVideo').value.trim() || null;
            const tagsInput = document.getElementById('inputTags').value;
            const tags = tagsInput ? tagsInput.split(',').map(t => parseInt(t.trim())).filter(t => !isNaN(t)) : [1];

            const shortcutData = {
                id: generateId(title),
                title: title,
                shortcut: shortcut,
                content: content,
                tags: tags,
                video: video
            };

            if (editingIndex >= 0) {
                shortcutsData.shortcuts[editingIndex] = shortcutData;
            } else {
                shortcutsData.shortcuts.push(shortcutData);
            }

            await saveData();
            renderItems();
            closeEditModal();
        });

        function openEditModal(index) {
            editingIndex = index;
            const shortcut = shortcutsData.shortcuts[index];
            document.getElementById('modalTitle').textContent = 'Edit Shortcut';
            document.getElementById('inputTitle').value = shortcut.title;
            document.getElementById('inputShortcut').value = shortcut.shortcut;
            document.getElementById('inputContent').value = shortcut.content.join('\n');
            document.getElementById('inputVideo').value = shortcut.video || '';
            document.getElementById('inputTags').value = shortcut.tags.join(',');
            document.getElementById('editModal').style.display = 'block';
        }

        function closeEditModal() {
            document.getElementById('editModal').style.display = 'none';
            editingIndex = -1;
        }

        async function deleteShortcut(index) {
            if (confirm('Are you sure you want to delete this shortcut?')) {
                shortcutsData.shortcuts.splice(index, 1);
                await saveData();
                renderItems();
            }
        }

        async function saveData() {
            try {
                const response = await fetch('/api/shortcuts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(shortcutsData)
                });
                if (!response.ok) throw new Error('Failed to save');
            } catch (error) {
                console.error('Error saving data:', error);
                alert('Failed to save. Changes are only in memory.');
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            loadData();
        });

        // Close modal on outside click
        window.onclick = function(event) {
            const modal = document.getElementById('editModal');
            if (event.target == modal) {
                closeEditModal();
            }
        }
    </script>
</body>
</html>

